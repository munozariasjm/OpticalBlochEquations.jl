[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Rendered Jupyter notebooks for examples in OpticalBlochEquations.jl."
  },
  {
    "objectID": "ipynb_sources/Blue-detuned MOT (CaOH).html",
    "href": "ipynb_sources/Blue-detuned MOT (CaOH).html",
    "title": "OpticalBlochEquations.jl",
    "section": "",
    "text": "using Revise\n\n\nusing\n    QuantumStates,\n    OpticalBlochEquations,\n    DifferentialEquations,\n    UnitsToValue\n\n\nusing Distributions\nuniform_dist = Uniform(0, 2π)\nfunction sample_direction(r=1.0)\n    θ = 2π * rand()\n    z = rand() * 2 - 1\n    return (r * sqrt(1 - z^2) * cos(θ), r * sqrt(1 - z^2) * sin(θ), r * z)\nend\n;\n\n\n\n\nValues are from Steck notes of the 87Rb D2 line\nEnergies are in MHz\n\n\nλ = 780.241209686e-9\nΓ = 2π * 6.065e6 # in units of MHz\nm = @with_unit 87 \"u\"\nk = 2π / λ\n;\n\n\\(5^2S_{1/2}\\) state\n\n# F = 1\nQN_bounds = (E = 0.0, F = 1)\nF1_lower = enumerate_states(AngularMomentumState, QN_bounds)\n\n# F = 2\nQN_bounds = (E = 6.83468261090429e9, F = 2) # GHz (in units of MHz)\nF2_lower = enumerate_states(AngularMomentumState, QN_bounds)\n;\n\n\\(5^2P_{3/2}\\)\n\nE_upper = 384.2304844685e12 # THz (in units of MHz)\n\n# F = 1\nQN_bounds = (E = E_upper - 72.9113e6 - 156.947e6, F = 1)\nF1_upper = enumerate_states(AngularMomentumState, QN_bounds)\n\n# F = 2\nQN_bounds = (E = E_upper - 72.9113e6, F = 2)\nF2_upper = enumerate_states(AngularMomentumState, QN_bounds)\n;\n\n\nground_states = [F1_lower; F2_lower]\nexcited_states = [F1_upper; F2_upper]\nstates = [ground_states; excited_states]\n;\n\n\nd = zeros(length(states), length(states), 3)\nfor (i, state) in enumerate(ground_states)\n    for (j, state′) in enumerate(excited_states)\n        j += length(ground_states)\n        for p in -1:1\n            tdm = TDM(state, state′, p)\n            d[i,j,p+2] = tdm\n            # d[j,i,p+2] = conj(tdm)\n        end\n    end\nend\n\n# Magnetic moments in units of MHz/G\n# For now, only assuming a field along the z axis\nd_m = zeros(length(states), length(states), 3)\nfor (i, state) in enumerate(states)\n    for (j, state′) in enumerate(states)\n        for p ∈ -1:1\n            if j > i\n                d_m[i,j,p+2] += TDM_magnetic(state, state′, p) * (state.E == state′.E)\n                d_m[i,j,p+2] += TDM_magnetic(state′, state, p) * (state.E == state′.E)\n            elseif i == j\n                d_m[i,j,p+2] += TDM_magnetic(state, state′, p) * (state.E == state′.E)\n            end\n        end\n    end\nend\nd_m[1:3,1:3,:]     .*= (-1/2)\nd_m[4:8,4:8,:]     .*= ( 1/2)\nd_m[9:11,9:11,:]   .*= (2/3)\nd_m[12:16,12:16,:] .*= (2/3)\n# d_m ./= (Γ / (μB * 1e6))\n;\n\n\n# Laser parameters\nδf11 = +11.5e6\nδf22 = +26.0e6\nθ₁ = 0.0\nθ₂ = 0.0\n\nIsat = 2.503\ns = (113 / Isat) / 12\n\n# pol = σ⁻\npol = σ⁺\n\n# Create MOT beams for F=1 -> F'=1 transition\nω_F1_to_F1 = 2π * (F1_upper[1].E - F1_lower[1].E + δf11)\n\nk̂ = +x̂\nϵ = exp(im * θ₁) * rotate_pol(pol, k̂)\nlaser1 = Laser(k̂, ϵ, ω_F1_to_F1, s)\n\nk̂ = -x̂\nϵ = exp(im * θ₁) * rotate_pol(pol, k̂)\nlaser2 = Laser(k̂, ϵ, ω_F1_to_F1, s)\n\nk̂ = +ŷ\nϵ = exp(im * θ₂) * rotate_pol(pol, k̂)\nlaser3 = Laser(k̂, ϵ, ω_F1_to_F1, s)\n\nk̂ = -ŷ\nϵ = exp(im * θ₂) * rotate_pol(pol, k̂)\nlaser4 = Laser(k̂, ϵ, ω_F1_to_F1, s)\n\nk̂ = +ẑ\nϵ = rotate_pol(pol, k̂)\nlaser5 = Laser(k̂, ϵ, ω_F1_to_F1, s)\n\nk̂ = -ẑ\nϵ = rotate_pol(pol, k̂)\nlaser6 = Laser(k̂, ϵ, ω_F1_to_F1, s)\n\n# Create MOT beams for F=2 -> F'=2 transition\nω_F2_to_F2 = 2π * (F2_upper[1].E - F2_lower[1].E + δf22)\n\nk̂ = +x̂\nϵ = exp(im * θ₁) * rotate_pol(pol, k̂)\nlaser7 = Laser(k̂, ϵ, ω_F2_to_F2, s)\n\nk̂ = -x̂\nϵ = exp(im * θ₁) * rotate_pol(pol, k̂)\nlaser8 = Laser(k̂, ϵ, ω_F2_to_F2, s)\n\nk̂ = +ŷ\nϵ = exp(im * θ₂) * rotate_pol(pol, k̂)\nlaser9 = Laser(k̂, ϵ, ω_F2_to_F2, s)\n\nk̂ = -ŷ\nϵ = exp(im * θ₂) * rotate_pol(pol, k̂)\nlaser10 = Laser(k̂, ϵ, ω_F2_to_F2, s)\n\nk̂ = +ẑ\nϵ = rotate_pol(pol, k̂)\nlaser11 = Laser(k̂, ϵ, ω_F2_to_F2, s)\n\nk̂ = -ẑ\nϵ = rotate_pol(pol, k̂)\nlaser12 = Laser(k̂, ϵ, ω_F2_to_F2, s)\n\nlasers = [laser1, laser2, laser3, laser4, laser5, laser6, laser7, laser8, laser9, laser10, laser11, laser12]\n# lasers = [laser5, laser6, laser11, laser12] # only z beams\n;\n\n\nfreq_res = 1e-1\nω_min = freq_res\nperiod = 2π / ω_min\n\nρ0 = zeros(ComplexF64, length(states), length(states))\nρ0[3,3] = 1.0\n\nparticle = Particle()\nparticle.r0 = [0.0, 0.0, 0.0] \nparticle.v = [0.0, 0.0, 0.1] #5 .* sample_direction() #[0.0, 0.0, 0.5] # velocity is in m/s (divided by Γ/k for the simulation)\n\np = obe(ρ0, particle, states, lasers, d, d_m, true, true, λ, Γ, freq_res)\np.B = (0., 0., 5.) ./ (Γ / (_μB * 1e6))\n;\n\nLoadError: UndefVarError: _μB not defined\n\n\n\n# using BenchmarkTools\n# @btime ρ!(dρ, ρ0, p, 0.0)\n\n\nt_end = 20p.period\ntspan = (0., t_end)\nstep_size = 1e-3\nn_periods = 2\ntimes = range(t_end - n_periods * p.period, t_end, step=p.period * step_size)\n\nprob = ODEProblem(ρ!, p.ρ0_vec, tspan, p, reltol=1e-5) # callback=AutoAbstol(false, init_curmax=0.0)) # what does this do?\n;\n\n\n@time sol = DifferentialEquations.solve(prob, alg=DP5(), abstol=1e-5);\n\n 21.067959 seconds (35.42 M allocations: 4.191 GiB, 2.08% gc time, 96.56% compilation time)\n\n\n\nusing Plots\nplot_us = sol.u\nplot_ts = sol.t\n\nn_states = size(p.ρ_soa, 1)\nplot(size=(800, 400), ylim=(-0.1, 1.1), legend=nothing)\nfor i in 1:n_states\n    state_idx = n_states*(i-1) + i\n    plot!(plot_ts, [real(u[state_idx]) for u in plot_us])\nend\nplot!()\noffset = 0\nvline!([sol.t[end] - p.period - offset, sol.t[end] - offset], color=\"red\", linestyle=:dash)\n# vline!([280, 380], color=\"red\", linestyle=:dash)\n\n\n\n\n\nsol.u[end][end-2:end]\n\n3-element Vector{ComplexF64}:\n   1.9700131428947971 + 0.0im\n -0.06391252360445562 + 0.0im\n   0.5584231316344115 + 0.0im\n\n\n\nusing Statistics, LinearAlgebra\noffset = 0\nperiod_idx = find_idx_for_time(p.period, sol.t, true)\nforce_idxs = Int(length(sol.t) - 1/step_size - offset):(length(sol.t) - offset) # (period_idx - offset):(length(times) - offset)\n\n@time F = calculate_force_from_period(p, sol; force_idxs)\nprintln(\"Excited population: \", real(sum(diag(mean(sol.u[force_idxs]))[9:end])))\nprintln(\"Force: \", 1e3 .* F) #sign.(force) .* abs(force ⋅ p.particle.v) / norm(p.particle.v))\nprintln(\"Acceleration (10^3 m/s^2): \", 1e-3 * QuantumStates.ħ * p.k * Γ * F[3] / m)\n\n  0.247017 seconds (709.97 k allocations: 35.210 MiB, 7.05% gc time, 98.87% compilation time)\n\n\nLoadError: ArgumentError: use diagm instead of diag to construct a diagonal matrix\n\n\n\n\n\nfunction prob_func!(p, scan_values, i)\n    # Update velocity and position\n    p.v .= sample_direction(scan_values.v[i])\n    p.v .= round_vel(p.v, p.freq_res)    \n    p.r0 .= rand(uniform_dist, 3) .* 2π\n    return nothing\nend\nfunction param_func(p, scan_values, i)\n    return scan_values.v[i]\nend\nfunction output_func(p, sol)\n    f = real.(sol[end][end-2:end])\n    return (f ⋅ p.v) / norm(p.v)\nend\n;\n\n\nprob = ODEProblem(ρ!, p.ρ0_vec, tspan, p, save_on=false) \np.freq_res = 1e-2\nprob.p.B .= (0.0, 0.0, 0.0)\nvs = repeat([[0,1,2,3,4]; collect(5:5:40)], 50) ./ (Γ / k)\nscan_values = (v = vs,)\n;\n\n\n@time scan_params, forces = force_scan(prob, scan_values, prob_func!, param_func, output_func; n_threads=20);\n\n\nvs, averaged_forces = average_forces(scan_params, forces)\naveraged_forces[1] = 0.0\nplot(vs .* (Γ / k), (1e-3 * ħ * k * Γ / m) .* averaged_forces / t_end, legend=nothing)\n\n\n\n\n\nfunction prob_func!(p, scan_values, i)\n    # Update velocity and position\n    p.v .= sample_direction(scan_values.vs[i])\n    p.r0 .= rand(uniform_dist, 3) .* 2π\n    # Round `v` to ensure that the OBEs are periodic\n    p.v .= round_vel(p.v, p.freq_res)\n    p.B .= (0.0, 0.0, scan_values.Bz[i])\n    return nothing\nend\nfunction param_func(p, scan_values, i)\n    return p.B[3]\nend\nfunction output_func(p, sol)\n    f = real.(sol[end][end-2:end])\n    return f[3] #(f ⋅ p.v) / norm(p.v)\nend\n;\n\n\np = obe(ρ0, particle, states, lasers, d, d_m, true, true, λ, Γ, freq_res)\nprob = ODEProblem(ρ!, p.ρ0_vec, tspan, p, reltol=1e-5, save_on=false)\n\nn_samples = 50\n\nBzs = (0:5:100.0) ./ (Γ / (_μB * 1e6))\nvs  = 0.1 .* ones(length(Bzs))\n\nscan_values = (Bz = repeat(Bzs, n_samples), vs = repeat(vs, n_samples))\n@time scan_params, forces = force_scan(prob, scan_values, prob_func!, param_func, output_func);\n\n\nBzs, averaged_forces = average_forces(scan_params, forces)\nplot(Bzs, 1e3 * averaged_forces, legend=nothing)\n\n\n\n\n\n\nλ = 1\nΓ = 2π\nm = 1\nk_norm = 2π / λ\n;\n\n\n# F = 1\nQN_bounds = (E = 0.0, F = 1)\nF1_lower = enumerate_states(AngularMomentumState, QN_bounds)\nQN_bounds = (E = 1.0, F = 1)\nF1_upper = enumerate_states(AngularMomentumState, QN_bounds)\n;\n\n\nground_states = F1_lower\nexcited_states = F1_upper\nstates = [ground_states; excited_states]\n;\n\n\nd = zeros(length(states), length(states), 3)\nfor (i, state) in enumerate(ground_states)\n    for (j, state′) in enumerate(excited_states)\n        j += length(ground_states)\n        for p in -1:1\n            tdm = TDM(state, state′, p)\n            d[i,j,p+2] = tdm\n            d[j,i,p+2] = conj(tdm)\n        end\n    end\nend\n\n# Magnetic moments in units of MHz/G\n# For now, only assuming a field along the z axis\nd_m = zeros(length(states), length(states), 3)\nfor (i, state) in enumerate(states)\n    for (j, state′) in enumerate(states)\n        for p ∈ -1:1\n            if j > i\n                d_m[i,j,p+2] += TDM_magnetic(state, state′, p) * (state.E == state′.E)\n                d_m[i,j,p+2] += TDM_magnetic(state′, state, p) * (state.E == state′.E)\n            elseif i == j\n                d_m[i,j,p+2] += TDM_magnetic(state, state′, p) * (state.E == state′.E)\n            end\n        end\n    end\nend\n# d_m .+= permutedims(d_m, (2,1,3))\n# d_m ./= (Γ / μB) # There's a 2π factor here too but it's included in the simulation code\n;\n\n\n# Laser parameters\nΔ = -2.5Γ\ns = 1.0\nθ₁ = 0.0\nθ₂ = 0.0\n\n# Create MOT beams for F=1 -> F'=1 transition\nω_F1_to_F1 = 2π * (F1_upper[1].E - F1_lower[1].E) + Δ\n\nk = +x̂\nϵ = exp(im * θ₁) * rotate_pol(σ⁺, k)\nlaser1 = Laser(k, ϵ, ω_F1_to_F1, s)\n\nk = -x̂\nϵ = exp(im * θ₁) * rotate_pol(σ⁺, k)\nlaser2 = Laser(k, ϵ, ω_F1_to_F1, s)\n\nk = +ŷ\nϵ = exp(im * θ₂) * rotate_pol(σ⁺, k)\nlaser3 = Laser(k, ϵ, ω_F1_to_F1, s)\n\nk = -ŷ\nϵ = exp(im * θ₂) * rotate_pol(σ⁺, k)\nlaser4 = Laser(k, ϵ, ω_F1_to_F1, s)\n\nk = +ẑ\nϵ = rotate_pol(σ⁺, k)\nlaser5 = Laser(k, ϵ, ω_F1_to_F1, s)\n\nk = -ẑ\nϵ = rotate_pol(σ⁺, k)\nlaser6 = Laser(k, ϵ, ω_F1_to_F1, s)\n\nlasers = [laser1, laser2, laser3, laser4, laser5, laser6]\n# lasers = [laser1, laser2]\n# lasers = [laser3, laser4]\n# lasers = [laser5, laser6]\n;\n\n\nfreq_res = 1e-1\nω_min = freq_res\nperiod = 2π / ω_min\n\nρ0 = zeros(ComplexF64, length(states), length(states))\nρ0[2,2] = 1.0\n\nparticle = Particle()\nparticle.r0 = [0.0, 0.0, 0.0] # ./ k_norm\nparticle.v = [0.0, 0.0, 0.1] #.* (Γ / k_norm)\n\np = obe(ρ0, particle, states, lasers, d, d_m, true, true, λ, Γ, freq_res)\np.B .= (0.0, 0.0, 25.0) ./ (Γ / (_μB * 1e6))\n;\n\n\n# using BenchmarkTools\n# dρ = deepcopy(ρ0)\n# @btime ρ!(dρ, ρ0, p, 0.0)\n\n\nt_end = 4period\ntspan = (0., t_end)\ntimes = range(0, t_end, step=period/1000)\n# times = range(t_end - 3p.period, t_end, step=period/1000)\n\nprob = ODEProblem(ρ!, p.ρ0_vec, tspan, p, saveat=times)#, callback=AutoAbstol(false, init_curmax=0.0)) # what does this do?\n;\n\n\n@time sol = DifferentialEquations.solve(prob, alg=DP5(), abstol=1e-4);\n\n\nusing Plots\nplot_us = sol.u\nplot_ts = sol.t\n\nn_states = size(p.ρ_soa, 1)\nplot(size=(800, 400), ylim=(-0.1, 1.1), legend=nothing)\nfor i in 1:n_states\n    state_idx = n_states*(i-1) + i\n    plot!(plot_ts, [real(u[state_idx]) for u in plot_us])\nend\nplot!()\noffset = 0\nvline!([sol.t[end] - p.period - offset, sol.t[end] - offset], color=\"red\", linestyle=:dash)\n# vline!([280, 380], color=\"red\", linestyle=:dash)\n\n\nusing Statistics, LinearAlgebra\noffset = 0\nperiod_idx = find_idx_for_time(p.period, sol.t, true)\nforce_idxs = (period_idx - offset + 1):(length(times) - offset)\n\n@time F = calculate_force_from_period(p, sol; force_idxs)\nprintln(\"Excited population: \", real(sum(diag(mean(sol.u[period_idx:end]))[4:end])))\nprintln(\"Force: \", 1e3 .* F) #sign.(force) .* abs(force ⋅ p.particle.v) / norm(p.particle.v))\nprintln(\"Acceleration (10³ m/s^2): \", 1e-3 * QuantumStates.ħ * k_norm * Γ * F / m)\n\n\n\n\nfunction prob_func!(p, scan_values, i)\n    # Update velocity and position\n    p.v .= (scan_values.v[i], 0.0, 0.1) #sample_direction(inner_config.v[i])\n    p.r0 .= rand(uniform_dist, 3) .* 2π\n    return nothing\nend\nfunction param_func(p, scan_values, i)\n    return round(norm(p.v), digits=2)\nend\nfunction output_func(p, sol)\n    f = sol[end][end]\n    return f[1]\nend\n;\n\n\nvs = repeat(0:0.2:7, 100)\nscan_values = (v = vs,)\n@time scan_params, forces = force_scan(prob, scan_values, prob_func!, param_func, output_func);\n\n\nvs, averaged_forces = average_forces(scan_params, forces)\nplot(vs, 1e3 .* averaged_forces, legend=nothing)\n\n\n\n\n\nfunction prob_func!(p, scan_values, i)\n    # Update velocity and position\n    p.v .= sample_direction(scan_values.vs[i])\n    p.r0 .= rand(uniform_dist, 3) .* 2π\n    # Round `v` to ensure that the OBEs are periodic\n    p.v .= round_vel(p.v, p.freq_res)\n    p.B .= (0.0, 0.0, scan_values.Bz[i])\n    return nothing\nend\nfunction param_func(p, scan_values, i)\n    return p.B[3]\nend\nfunction output_func(p, sol)\n    f = real.(sol[end][end-2:end])\n    # return f ⋅ p.v / norm(p.v)\n    return f[3]\nend\n;\n\n\np = obe(ρ0, particle, states, lasers, d, d_m, true, true, λ=λ, Γ=Γ, freq_res=freq_res)\nODEProblem(ρ!, p.ρ0_vec, tspan, p, save_on=false)\n\nn_samples = 300\n\nBzs = (0:5:50) ./ (Γ / (_μB * 1e6))\nvs  = 0.1 .* ones(length(Bzs))\nscan_values = (Bz = repeat(Bzs, n_samples), vs = repeat(vs, n_samples))\n\n@time scan_params, forces = force_scan(prob, scan_values, prob_func!, param_func, output_func);\n\n\nBzs, averaged_forces = average_forces(scan_params, forces)\nplot(Bzs, 1e3 * averaged_forces / t_end, legend=nothing)\n\n\n\n\n# Dense output, how does it compare?\n@time sol = DifferentialEquations.solve(prob, alg=DP5(), abstol=1e-6, reltol=1e-7, dense=true);\n\n\nfor i in 1:6\n    plot!(i, [real(sol(j)[i,i]) for j in 1:p.period])\nend\nplot!()\noffset = 0\nvline!([sol.t[end] - period - offset, sol.t[end] - offset], color=\"red\", linestyle=:dash)\n\n\nts = 500:0.001:1000\nsum(sol(t) for t ∈ ts) ./ length(ts) |> diag\n\n\n\n\n\n\n\nλ = 626e-9\nΓ = 2π * 6.4e6 # in units of MHz\nm = @with_unit 57 \"u\"\nk = 2π / λ\n;\n\n\n\n\nHX = load_from_file(\"CaOH_000_N0to3_Hamiltonian\", \"X://My Drive//github//QuantumStates//Hamiltonians//\")\nHA = load_from_file(\"CaOH_A000_J12to52_Hamiltonian\", \"X://My Drive//github//QuantumStates//Hamiltonians//\")\n\nHX_N1 = subspace(HX, (N=1,))\nHA_J12 = subspace(HA, (Ω=1/2, J=1/2,))\nevaluate!(HX_N1); QuantumStates.solve!(HX_N1)\nevaluate!(HA_J12); QuantumStates.solve!(HA_J12)\n\n# Add Zeeman term to the X state Hamiltonian\n_μB = (μ_B / h) * (1e-6 * 1e-4)\nZeeman_z(state, state′) = Zeeman(state, state′, 0)\nHX_N1 = add_to_H(HX_N1, :B_z, gS * _μB * Zeeman_z)\nHX_N1.parameters.B_z = 0.0\n\n# Convert A states from Hund's case (a) to case (b)\nHX_0110 = load_from_file(\"CaOH_BendingMode_Hamiltonian\", \"X://My Drive//github//QuantumStates//Hamiltonians//\")\nstates_A_J12_caseB = convert_basis(HA_J12.states, HX_0110.basis)\nbasis_idxs, reduced_A_J12_caseB_basis = states_to_basis(states_A_J12_caseB)\nfull_basis = [HX_N1.basis; reduced_A_J12_caseB_basis]\n\nfor i ∈ eachindex(states_A_J12_caseB)\n    states_A_J12_caseB[i].coeffs = states_A_J12_caseB[i].coeffs[basis_idxs]\n    states_A_J12_caseB[i].basis = reduced_A_J12_caseB_basis\nend\n\nstates = [HX_N1.states; states_A_J12_caseB]\nfor state ∈ states\n    state.E *= 1e6\nend\n;\n\n\nd = zeros(ComplexF64, 16, 16, 3)\nd_ge = zeros(ComplexF64, 12, 4, 3)\nbasis_tdms = get_tdms_two_bases(HX_N1.basis, reduced_A_J12_caseB_basis, TDM)\ntdms_between_states!(d_ge, basis_tdms, HX_N1.states, states_A_J12_caseB)\nd[1:12, 13:16, :] .= d_ge\n\nd_m = zeros(ComplexF64, 16, 16, 3)\nd_m_gg = zeros(ComplexF64, 12, 12, 3)\nbasis_tdms_m = get_basis_tdms(HX_N1.basis, TDM_magnetic)\ntdms_between_states!(d_m_gg, basis_tdms_m, HX_N1.states, HX_N1.states)\nd_m[1:12, 1:12, :] .= d_m_gg\n;\n\n\n# Laser parameters\nJ12_energy = energy(states[1])\nJ32_energy = energy(states[5])\nA_energy = energy(states[13])\n\nδJ12 = +13.0e6\nδJ32 = +13.0e6\nθ₁ = 0.0\nθ₂ = 0.0\ns_J12 = 5.0\ns_J32 = 5.0\npol = σ⁻\n\nω_J12 = 2π * (A_energy - J12_energy + δJ12)\nω_J32 = 2π * (A_energy - J32_energy + δJ32)\n\nϵ = exp(im * θ₁) * rotate_pol(pol, +x̂); laser1 = Laser(+x̂, ϵ, ω_J12, s_J12)\nϵ = exp(im * θ₁) * rotate_pol(pol, -x̂); laser2 = Laser(-x̂, ϵ, ω_J12, s_J12)\nϵ = exp(im * θ₂) * rotate_pol(pol, +ŷ); laser3 = Laser(+ŷ, ϵ, ω_J12, s_J12)\nϵ = exp(im * θ₂) * rotate_pol(pol, -ŷ); laser4 = Laser(-ŷ, ϵ, ω_J12, s_J12)\nϵ = rotate_pol(pol, +ẑ); laser5 = Laser(+ẑ, ϵ, ω_J12, s_J12)\nϵ = rotate_pol(pol, -ẑ); laser6 = Laser(-ẑ, ϵ, ω_J12, s_J12)\n\nϵ = exp(im * θ₁) * rotate_pol(pol, +x̂); laser7 = Laser(+x̂, ϵ, ω_J32, s_J32)\nϵ = exp(im * θ₁) * rotate_pol(pol, -x̂); laser8 = Laser(-x̂, ϵ, ω_J32, s_J32)\nϵ = exp(im * θ₂) * rotate_pol(pol, +ŷ); laser9 = Laser(+ŷ, ϵ, ω_J32, s_J32)\nϵ = exp(im * θ₂) * rotate_pol(pol, -ŷ); laser10 = Laser(-ŷ, ϵ, ω_J32, s_J32)\nϵ = rotate_pol(pol, +ẑ); laser11 = Laser(+ẑ, ϵ, ω_J32, s_J32)\nϵ = rotate_pol(pol, -ẑ); laser12 = Laser(-ẑ, ϵ, ω_J32, s_J32)\n\nlasers = [laser1, laser2, laser3, laser4, laser5, laser6, laser7, laser8, laser9, laser10, laser11, laser12]\n;\n\n\n# Set initial conditions\nparticle = Particle()\nparticle.r0 = [0.0, 0.0, 0.0]\nparticle.v = [0.0, 0.0, 0.0]\n\nρ0 = zeros(ComplexF64, length(states), length(states)) # Use a static array for this??? Might be better...\nρ0[1,1] = 1.0\n\nfreq_res = 1e-1\np = obe(ρ0, particle, states, lasers, d, d_m, true, true, λ, Γ, freq_res; basis_tdms, basis_tdms_m, HX_N1, d_ge, d_m_gg)\n\np.B .= (0.0, 0.0, 0.0) ./ (Γ / (_μB * 1e6))\np.v .= (0.0, 0.0, 4.0)\n\nt_end = 200p.period+1\ntspan = (0., t_end)\n# prob = ODEProblem(ρ!, ρ0, tspan, p, callback=force_cb, save_on=false) #, callback=AutoAbstol(false, init_curmax=0.0)) # what does this do?\n\n# ρ0_tmp = deepcopy(ρ0)\n# ρ0_tmp_all = [ρ0_tmp for _ in 1:length(times)]\n# @time sol = DifferentialEquations.solve(prob, DP5(), ρ0_tmp_all, abstol=1e-5);\n;\n\n\n# Implement a periodic callback to reset the force each period\nfunction reset_force!(integrator)\n    force_current_period = integrator.u[end-2:end] / integrator.p.period\n    force_diff = abs.(force_current_period - integrator.p.force_last_period)\n    integrator.p.force_last_period = force_current_period\n    force_tol = 1e-6\n    if force_diff[1] < force_tol && force_diff[2] < force_tol && force_diff[3] < force_tol\n        terminate!(integrator)\n    else\n        integrator.u[end-2:end] .= 0.0\n    end\n    return nothing\nend\ncb = PeriodicCallback(reset_force!, p.period)\n;\n\n\nusing StaticArrays\n\n\n# using BenchmarkTools\n# dρ = deepcopy(ρ0)\n# @time ρ!(dρ, ρ0, p, 0.0)\n# @btime ρ!($dρ, $ρ0, $p, 0.0)\n\n\nprob = ODEProblem(ρ!, p.ρ0_vec, tspan, p) \n@time sol = DifferentialEquations.solve(prob, DP5(), callback=cb, abstol=1e-5)\n;\n\n\ntspan\n\n\nsol.t[end]\n\n\nusing Plots\nplot_us = sol.u\nplot_ts = sol.t\n\nn_states = size(p.ρ_soa, 1)\nplot(size=(800, 400), ylim=(-0.1, 1.1), legend=nothing)\nfor i in 1:n_states\n    state_idx = n_states*(i-1) + i\n    plot!(plot_ts, [real(u[state_idx]) for u in plot_us])\nend\nplot!()\noffset = 0\nvline!([sol.t[end] - p.period - offset, sol.t[end] - offset], color=\"red\", linestyle=:dash)\n# vline!([280, 380], color=\"red\", linestyle=:dash)\n\n\nusing Statistics, LinearAlgebra\noffset = 0\nperiod_idx = find_idx_for_time(p.period, sol.t, true)\nforce_idxs = (period_idx - offset):(length(times) - offset)\n@time force_value = calculate_force_from_period(p, sol)\n\n# @time force = calculate_force_from_period(p, sol)\n# println(\"Excited population: \", real(sum(diag(mean(sol.u[force_idxs]))[9:end])))\nprintln(\"Force: \", force_value)\nprintln(\"Acceleration (10^3 m/s^2): \", 1e-3 * ħ * k * Γ * force_value[3] / m)\n\n\n\n\n\n# Why not use `EnsembleProblem`? This makes a new copy for every single problem, which we won't need\n# Instead, we make `nthreads` problems\n# prob = ODEProblem(ρ!, ρ0, tspan, p)\n# ensemble_prob = EnsembleProblem(prob, prob_func=prob_func_inner)\n# @time sim = solve(ensemble_prob, DP5(), EnsembleThreads(), trajectories=100, batch_size=10, abstol=1e-5, save_everystep=false)\n# ;\n\n\nfunction prob_func!(p, scan_values, i)\n    # Update velocity and position\n    p.v .= sample_direction(scan_values.v[i])\n    p.v .= round_vel(p.v, p.freq_res)    \n    p.r0 .= rand(uniform_dist, 3) .* 2π\n    return nothing\nend\nfunction param_func(p, scan_values, i)\n    return scan_values.v[i]\nend\nfunction output_func(p, sol)\n    f = p.force_last_period\n    return (f ⋅ p.v) / norm(p.v)\nend\n;\n\n\nfreq_res = 1e-1\np = obe(ρ0, particle, states, lasers, d, d_m, true, true, λ, Γ, freq_res; basis_tdms, basis_tdms_m, HX_N1, d_ge, d_m_gg)\n\ntspan = (0, 100p.period+1)\nprob = ODEProblem(ρ!, p.ρ0_vec, tspan, p, save_on=false) \n\nprob.p.B .= (0.0, 0.0, 0.0) ./ (Γ / (_μB * 1e6))\n\nn_samples = 100\nvs = repeat(0:1:40, n_samples) ./ (Γ / k)\nscan_values = (v = vs,)\n;\n\n\n@time scan_params, forces = force_scan(prob, scan_values, prob_func!, param_func, output_func);\n\n\nvs, averaged_forces = average_forces(scan_params, forces)\naveraged_forces[1] = 0.0\nplot(vs .* (Γ / k), (1e-3 * ħ * k * Γ / m) .* averaged_forces / t_end, legend=nothing)\n\n\n\n\n\nfunction prob_func!(p, scan_values, i)\n    # Update velocity and position\n    p.v .= sample_direction(scan_values.v[i])\n    p.r0 .= rand(uniform_dist, 3) .* 2π\n    # Round `v` to ensure that the OBEs are periodic\n    p.v .= round_vel(p.v, p.freq_res)\n    \n    # Solve Hamiltonian for new `Bz` value (this is expensive, so only do it if the value has changed)\n    Bz = scan_values.Bz[i]\n    if p.HX_N1.parameters.B_z != Bz\n        p.B .= (0.0, 0.0, Bz)\n        p.HX_N1.parameters.B_z = scan_values.Bz[i]\n        evaluate!(HX_N1)\n        QuantumStates.solve!(HX_N1)\n        for i ∈ eachindex(HX_N1.states)\n            HX_N1.states[i].E *= 1e6\n        end\n        p.states[1:12] .= HX_N1.states\n\n        # Update TDMs\n        tdms_between_states!(p.d_ge, p.basis_tdms, HX_N1.states, states_A_J12_caseB)\n        p.d[1:12, 13:16, :] .= d_ge\n        tdms_between_states!(d_m_gg, p.basis_tdms_m, HX_N1.states, HX_N1.states)\n        p.d_m[1:12, 1:12, :] .= d_m_gg\n    end\n    \n    return nothing\nend\nfunction param_func(p, scan_values, i)\n    return scan_values.Bz[i]\nend\nfunction output_func(p, sol)\n    f = calculate_force_from_period(p, sol)\n    return f[3] #(f ⋅ p.v) / norm(p.v)\nend\n;\n\n\nn_samples = 10\n\nBzs = (0:2:50) ./ (Γ / (_μB * 1e6))\nvs  = (1.0 / (Γ / k)) .* ones(length(Bzs))\n\nscan_values = (Bz = repeat(Bzs, n_samples), v = repeat(vs, n_samples))\n@time scan_params, forces = force_scan(prob, scan_values, prob_func!, param_func, output_func);\n\n\nBzs, averaged_forces = average_forces(scan_params, forces)\nplot(Bzs .* (Γ / (_μB * 1e6)), (1e-3 * ħ * k * Γ / m) .* averaged_forces, legend=nothing)"
  }
]